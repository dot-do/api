/**
 * Types command - generate TypeScript types from API schemas
 */

import { discover } from '../../discovery/index.js'
import type { JSONSchema } from '../../types.js'
import { validateUrl, formatError } from '../utils.js'

export interface TypesOptions {
  url: string
  output?: string
  namespace?: string
}

/**
 * Convert JSON Schema to TypeScript type
 */
function schemaToType(schema: JSONSchema, _name?: string, indent: number = 0): string {
  const pad = '  '.repeat(indent)

  if (!schema || typeof schema !== 'object') {
    return 'unknown'
  }

  if (schema.$ref) {
    // Extract type name from $ref
    const refName = schema.$ref.split('/').pop() || 'unknown'
    return refName
  }

  if (schema.oneOf) {
    return schema.oneOf.map(s => schemaToType(s, undefined, indent)).join(' | ')
  }

  if (schema.anyOf) {
    return schema.anyOf.map(s => schemaToType(s, undefined, indent)).join(' | ')
  }

  if (schema.allOf) {
    return schema.allOf.map(s => schemaToType(s, undefined, indent)).join(' & ')
  }

  if (schema.enum) {
    return schema.enum.map(v => JSON.stringify(v)).join(' | ')
  }

  if (schema.const !== undefined) {
    return JSON.stringify(schema.const)
  }

  const type = schema.type

  if (Array.isArray(type)) {
    return type.map(t => schemaTypeToTs(t)).join(' | ')
  }

  if (type === 'object') {
    if (!schema.properties || Object.keys(schema.properties).length === 0) {
      return 'Record<string, unknown>'
    }

    const required = new Set(schema.required || [])
    const props = Object.entries(schema.properties)
      .map(([key, propSchema]) => {
        const optional = required.has(key) ? '' : '?'
        const propType = schemaToType(propSchema as JSONSchema, undefined, indent + 1)
        return `${pad}  ${safeName(key)}${optional}: ${propType}`
      })
      .join('\n')

    return `{\n${props}\n${pad}}`
  }

  if (type === 'array') {
    if (schema.items) {
      if (Array.isArray(schema.items)) {
        const types = schema.items.map(s => schemaToType(s as JSONSchema, undefined, indent))
        return `[${types.join(', ')}]`
      }
      return `Array<${schemaToType(schema.items as JSONSchema, undefined, indent)}>`
    }
    return 'unknown[]'
  }

  return schemaTypeToTs(type)
}

function schemaTypeToTs(type: string | undefined): string {
  switch (type) {
    case 'string':
      return 'string'
    case 'number':
    case 'integer':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'null':
      return 'null'
    case 'object':
      return 'Record<string, unknown>'
    case 'array':
      return 'unknown[]'
    default:
      return 'unknown'
  }
}

function safeName(name: string): string {
  if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
    return name
  }
  return `'${name}'`
}

export async function typesCommand(options: TypesOptions): Promise<number> {
  const { url, output, namespace = 'API' } = options

  if (!validateUrl(url)) {
    console.error(formatError(new Error(`Invalid URL: ${url}`)))
    return 1
  }

  try {
    const result = await discover({ baseUrl: url })
    const lines: string[] = []

    lines.push('/**')
    lines.push(` * Generated types for ${url}`)
    lines.push(` * Generated by api.qa`)
    lines.push(' */')
    lines.push('')

    lines.push(`declare namespace ${namespace} {`)

    // Generate types from MCP tools
    if (result.mcp) {
      lines.push('  // MCP Tool Types')
      for (const tool of result.mcp.tools) {
        const typeName = tool.name
          .split('.')
          .map(s => s.charAt(0).toUpperCase() + s.slice(1))
          .join('')

        if (tool.inputSchema) {
          lines.push(`  export interface ${typeName}Input ${schemaToType(tool.inputSchema, undefined, 1)}`)
          lines.push('')
        }

        if (tool.outputSchema) {
          lines.push(`  export interface ${typeName}Output ${schemaToType(tool.outputSchema, undefined, 1)}`)
          lines.push('')
        }
      }
    }

    // Generate types from RPC methods
    if (result.rpc) {
      lines.push('  // RPC Method Types')
      for (const method of result.rpc.schema.methods) {
        const typeName = method.path
          .split('.')
          .map(s => s.charAt(0).toUpperCase() + s.slice(1))
          .join('')

        if (method.inputSchema) {
          lines.push(`  export interface ${typeName}Input ${schemaToType(method.inputSchema, undefined, 1)}`)
          lines.push('')
        }

        if (method.outputSchema) {
          lines.push(`  export interface ${typeName}Output ${schemaToType(method.outputSchema, undefined, 1)}`)
          lines.push('')
        }
      }
    }

    // Generate types from REST endpoints
    if (result.rest?.endpoints) {
      lines.push('  // REST Endpoint Types')
      for (const endpoint of result.rest.endpoints as Array<{ path: string; method: string; inputSchema?: JSONSchema; outputSchema?: JSONSchema }>) {
        const typeName = `${endpoint.method}${endpoint.path}`
          .replace(/[^a-zA-Z0-9]/g, '_')
          .replace(/_+/g, '_')
          .split('_')
          .map(s => s.charAt(0).toUpperCase() + s.slice(1).toLowerCase())
          .join('')

        if (endpoint.inputSchema) {
          lines.push(`  export interface ${typeName}Input ${schemaToType(endpoint.inputSchema, undefined, 1)}`)
          lines.push('')
        }

        if (endpoint.outputSchema) {
          lines.push(`  export interface ${typeName}Output ${schemaToType(endpoint.outputSchema, undefined, 1)}`)
          lines.push('')
        }
      }
    }

    lines.push('}')
    lines.push('')
    lines.push(`export = ${namespace}`)
    lines.push('')

    const content = lines.join('\n')

    if (output) {
      const fs = await import('fs')
      fs.writeFileSync(output, content)
      console.log(`Types written to ${output}`)
    } else {
      console.log(content)
    }

    return 0
  } catch (error) {
    console.error(formatError(error as Error))
    return 1
  }
}
